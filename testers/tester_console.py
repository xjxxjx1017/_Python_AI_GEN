
from third_party import system_plus

class TesterConsole():
    lastTest = []
    lastCommand = []

    def run(self):
        # * Show some 'help' at the start of the program
        self.printHelp()

        command = ""
        while command is not "quit":
            command = input()
			# * Do some command
            self.doCommand( command )

    def doCommand( self, command ):
        # # parse command as a lower case string
        command = command.lower()
        # * Split the command into little commands
        commands = system_plus.splitCommand( command )
        # * Save the command as the last command
        if commands[0] != 'r' and ( len(commands) != 0 and command != self.lastCommand ):
            self.lastCommand += command
        # * Parse commands and run it!
        self.parseCommand( commands )
        print( commands )

    def parseCommand(self, commands):
        parameters = []


    def printHelp(self):
        print("""
////////////// HELP //////////////////
help                For help
quit                Quit the console
start               Run a standard test
filter x x x x      Run a filter test, only record the test we wanted
                        p1: min years
                        p2: max years
                        p3: min creatures
                        p4: max creatures
single x x          Run series of tests for a single configuration generated
                    by a certain seed
                        p1: a fixed seed for the simulation
                        p2: number of times for the simulation
r (x)               Redo the last 'n' command
                        p1 (=1): the previous 'n' test that you want to execute
[integer]           If the input is an integer, print the detail of a test has
                    the same ID as the integer
//////////////////////////////////////""")


# ================================================================================


class Program(object):
	def __init__(self):

	def Main(args):
		# * Show some 'help' at the start of the program
		Program.printHelp()
		# * Prevent the console from shutting down.
		command = ""
		self._lastCommand = List[str]()
		while command.Equals("quit") == False:
			command = Console.ReadLine()
			# [] Stop any false command from breaking the program
			try:
				# * Do some command
				Program.doCommand(command)
			except Exception, e:
			finally:

	Main = staticmethod(Main)

	def doCommand(command):
		# # parse command as a lower case string
		command = command.ToLower()
		# * Split the command in to little commands
		commands = SystemPlus.splitCommand(command)
		# * Save the command as the last command
		if commands[0] != "r" and (self._lastCommand.Count == 0 or self._lastCommand[self._lastCommand.Count - 1] != command):
			self._lastCommand.Add(command)
		# * Parse commands and run it !
		Program.parseCommand(commands)

	doCommand = staticmethod(doCommand)

	def parseCommand(commands):
		parameters = Array.CreateInstance(int, 10)
		if commands[0] == "help":
			# * Show some 'help'
			Program.printHelp()
		elif commands[0] == "start":
			# * Run a standard test
			Program.runTest()
		elif commands[0] == "filter":
			# * Run a filter test, only record the test we wanted
			parameters[0] = Convert.ToInt32(commands[1])
			parameters[1] = Convert.ToInt32(commands[2])
			parameters[2] = Convert.ToInt32(commands[3])
			parameters[3] = Convert.ToInt32(commands[4])
			Program.runFilterTest(10, parameters[0], parameters[1], parameters[2], parameters[3])
		elif commands[0] == "single":
			# * Run a serials test for a single configuration generated by a certain seed
			parameters[0] = Convert.ToInt32(commands[1])
			parameters[1] = Convert.ToInt32(commands[2])
			Program.runSingleTest(parameters[0], parameters[1])
		elif commands[0] == "r":
			# * Redo the last 'n' command
			if commands.Count > 1:
				parameters[0] = Convert.ToInt32(commands[1])
				commandL = self._lastCommand[self._lastCommand.Count - parameters[0]]
				Program.doCommand(commandL)
			else:
				Program.doCommand(self._lastCommand[self._lastCommand.Count - 1])
		else:
			# * If the input is an integer, print the config id
			id = Convert.ToInt32(commands[0])
			if id > 0:
				index = id - 1
				seed = self._lastTest[index].seed
				config = DynamicConfig.generate(seed).ToString()
				Console.WriteLine(config)
				Console.WriteLine(self._lastTest[index].ToStringLimit(20))

	parseCommand = staticmethod(parseCommand)

	def printHelp():
		Console.WriteLine("////////////// HELP //////////////////")
		Console.WriteLine("help" + "\n\t\tFor help")
		Console.WriteLine("start" + "\n\t\tRun a standard test")
		Console.WriteLine("filter x x x x" + "\n\t\tRun a filter test, only record the test we wanted")
		Console.WriteLine("\t\t\tp1: min years\n" + "\t\t\tp2: max years\n" + "\t\t\tp3: min ships\n" + "\t\t\tp4: max ships")
		Console.WriteLine("single x x" + "\n\t\tRun a serials test for a single configuration generated \n\t\t" + "by a certain seed")
		Console.WriteLine("\t\t\tp1: a fixed seed for the simulation\n" + "\t\t\tp2: number of times for the simulation\n")
		Console.WriteLine("r (x)" + "\n\t\tRedo the last 'n' command")
		Console.WriteLine("\t\t\tp1 (=1): define the number of 'n'\n")
		Console.WriteLine("[integer]" + "\n\t\tIf the input is an integer, print the detail of a test has \n\t\t" + "the same ID as the integer")
		Console.WriteLine("//////////////////////////////////////")

	printHelp = staticmethod(printHelp)

	def printResult(uList):
		Console.Clear()
		i = 0
		while i < uList.Count:
			u = uList[i]
			Console.WriteLine("ID: " + (i + 1) + "\tSeed: " + u.seed + "\tEnd year: " + u.rlt_endYear + "\tShip count: " + u.rlt_shipCount)
			i += 1

	printResult = staticmethod(printResult)

	def runSingleTest(seed, times):
		# * Config params for testing
		uList = List[Universe]()
		universeMax = times
		# * Run test for a fixed seed
		while uList.Count < universeMax:
			u = Universe()
			u.run(seed)
			uList.Add(u)
		# [] Print results
		Program.printResult(uList)
		self._lastTest = uList

	runSingleTest = staticmethod(runSingleTest)

	def runFilterTest(count, minYear, maxYear, minShips, maxShips):
		# * Config params for testing
		uList = List[Universe]()
		universeMax = 10
		# * Run test
		seed = 1
		while uList.Count < universeMax:
			u = Universe()
			u.run(seed)
			if u.rlt_endYear <= maxYear and u.rlt_endYear >= minYear and u.rlt_shipCount >= minShips and u.rlt_shipCount <= maxShips:
				uList.Add(u)
			seed += 1
		# [] Print results
		Program.printResult(uList)
		self._lastTest = uList

	runFilterTest = staticmethod(runFilterTest)

	def runTest(count):
		pass

	runTest = staticmethod(runTest)